# Проект: Аутентификация


*Не забудьте использовать GIT чтобы сохранить свой проект!*

В этом проекте Вы будете работать над реализацией систем аутентификации чтобы пользователи имели доступ только к тем разделам сайта, к которым они авторизованы.

## Проект 1: Руководство по Ruby on Rails 

We're starting to get into the meaty stuff with the tutorial. Не торопитесь и обратите внимание в какой файл(особенно для спецификаций) Вы  долженны писать. Распространенная и разочаровывющая ошибка поставить блок `describe` не в то место.

Вы будете реализовывать возможность авторизации и выхода со страницы для пользователя, которая позволяет ему осуществлять более вредные вещи такие как редактирование и удаление (которые должны быть разрешены только данному пользователю или админу). В главе 9 у Вас будет шанс реализовать эти функции.

### Ваша задача

1. Сделайте [Ruby on Rails Tutorial Chapter 8](https://www.railstutorial.org/book/log_in_log_out), "Log in, log out"
2. Сделайте [Ruby on Rails Tutorial Chapter 9](http://www.railstutorial.org/book/updating_and_deleting_users), "Updating, showing and deleting users"


## Проект 2: Только участникам!

В этом проекте Вы будете строить эксклюзивную халабуду, где участники смогут писать смущающие посты про не участников. Внутри халабуды участники могут видеть кто автор поста, но снаружи они могут могут видеть только историю и удивляться, кто ее написал.

Это буде Ваш шанс "развернуть" собственную систему аутентификации очень похожую на ту, которую Вы делали в руководстве. Как обычно, мы сфокусируемся на данных и функции, не стилях. Если Вы хотите добавить свои собственные стилистические завитушки, считайте это дополнительными баллами.

Легко почувствовать себя немного ошеломленным написанием собственной атентификацией. Это потому, что есть несколько деталей - сеанс контроллер/форма, который цепляется и обновляет токен, если это необходимо, и использует этот токен чтобы зарегистрировать текущего пользователя. Это может помочь, если Вы выписываете шаги так как Вы их понимаете перед тем как начать, чтобы Вы знали где Ваши знания непрочны и нужно будет обратить на это внимание.

### Ваше задание

В проектах будет все меньше и меньше подробностей о том, как достичь целей, так как мы ожидаем что Вы базируетесь на знаниях полученных ранее. Если Вы не знаете как что-то сделать, то можете вернуться назад к прошлым урокам или проектам или загуглите как правильно реализовать это (но будьте осторожны, потому что Вы можете узнать больше, чем было нами задумано). Руководство по Ruby on Rails будет хорошей справкой.

До сих пор мы обходились с полем пароля в пользовательском контенте немного безцеремонно... в основном потому что *оно?* было добавлено позже для полноты картины. Мы, конечно, не хранили пароли правильно и не шифровали их, а должны были. Так что сотрите это со своей памяти потому что у нас есть инструменты чтобы должным образом шифровать пароли и мы будем делать это отныне. На самом деле, у Вас были инструменты еще в 6 главе в руководстве по Ruby on Rails.

Если Вы хотите бросить себе вызов, то не следуйте даже ниже написанным  шагам, просто идите вперед и пишите приложение!

#### Основные настройки

1. Подумайте и напишите спецификацию как создать Ваши модели данных для этого приложения. Вам нужны будут пользователи с обычными простыми атрибутами идентификации такими как имя, email и пароль, но также что-то типа индикатора о их статусе участника. Так же им понадобиться создавать посты. Учитывая то, что Вы знаете о паролях, Вы будете использовать поле `:password_digest` вместо поля `:password`.
2. Создайте Ваше новое `members-only` Rails приложение и репозиторий на Github.  Обновите свой README.
3. Начните с переноса и базовой настройки User model (пока никаких атрибутов участника).
4. Включите `bcrypt-ruby` gem в свой Gemfile.  `$ bundle install` его.  (на заметку: Это может быть просто `bcrypt`)
5. Добавьте  `#has_secure_password` метод в Ваш User file.
6. Перейдите в Rails console и создайте образец пользователя чтобы убедиться, что все работает правильно. Должно быть похоже на `User.create(:name => "foobar", :email => "foo@bar.com", :password => "foobar", :password_confirmation => "foobar")`
7. Протестируйте команду `#authenticate`  которая теперь доступна в Вашей User model (благодаря `#has_secure_password`) в командной строке -- возвращет ли она пользователя если ввести правильный пароль?
    
    ```bash
        > user = User.create(:name => "foobar", :email => "foo@bar.com", :password => "foobar", :password_confirmation => "foobar")
        > user.authenticate("somethingelse")
        => false
        > user.authenticate("foobar")
        => true
    ```

#### Сессии и Вход

А сейчас давайте убедимся, что наши пользователи могут войти.

1. Создайте `sessions_controller.rb` и соответствующие маршруты. Сделайте ссылки "Войти" в макете, если необходимо.
2. Заполните информацию в действии `#new` чтобы создать пустую сессию и отправьте на страницу.
3. Напишите простую форму с `#form_for` для входа пользователя в `app/views/sessions/new.html.erb`.  Убедитесь, что Вы можете видеть форму.
4.Мы хотим запоминать, что наш пользователь вошел, потому Вам нужно создать новую колонку типа string для Вашей User table, которая называется на подобии `:remember_token` которая будет хранить специальный токен пользователя.
5. Когда Вы создаете нового пользователя, Вы хотите присвоить этому пользователю совсем новый токен. Используйте`#before_create` callback в User model чтобы: 

    1. Создать токен (используйте `SecureRandom.urlsafe_base64` чтобы сгенерировать случайную строку)
    2. Зашифровать этот токен(используя метод `Digest::SHA1.hexdigest`  в строковой (`#to_s`) версии токена)
    3. Сохраните это для Вашего пользоввателя.

6. Создайте несколько пользователей чтобы заполнить Ваше приложение. Мы не будем писать регистрационную форму, так что нужно создавать новых пользователей через командную строку. Ваш `#before_create` сейчас должен правильно присваивать новым пользователям специальный токен.
7. Сейчас заполните в действии `#create` в Вашем SessionsController чтобы на самом деле создать сессию пользователя. Сначала нужно найти пользователя основываясь на адресе email, а затем сравнить хэш пароля , который он отправил в параметрах, с хэшированным паролем хранящимся в базе данных (используя `#authenticate`).  Смотрите [Главу 8](http://ruby.railstutorial.org/chapters/sign-in-sign-out#sec-reviewing_form_submission) с вопросами, но попытайтесь не копировать сразу дословно - Вы делаете это чтобы научиться.
8. Как только Вы подтвердите, что пользователь ввел правильный пароль, впустите его.
9. Создайте новый метод в ApplicationController который выполняет вход для Вас. Присвойте пользователю новый токен (так чтобы он не был чужим или устаревшим). Храните токен в браузере пользователя используя cookie, так всякий раз когда он посещяет новую страницу, мы можем проверять выполнен ли вход. Используйте `cookies.permanent` "hash" чтобы сделать это.
10. Создайте 2 других полезных метода в ApplicationController -- один чтобы возвращать текущего пользователя (`#current_user`) и другой чтобы устанавливать его (`#current_user=(user)`). В возвращении текущего пользователя должен использоваться оператор `||=` -- если текущий пользователь уже установлен, Вы должны вернуть этого пользователя, иначе, Вам нужно вытянуть токен из cookie и искать его в базе данных чтобы вытащить соответствующего пользователя.  Если пользователь не найден, то верните `nil`.
11. Устанавливайте текущего пользователя всегда когда пользователь осуществляет вход.
12. Напишите функцию выхода в действии `SessionsController#delete`  которая будет убирать текущего пользователя и удалять токен с cookie. Для этого лучше всего вызвать метод (например `#sign_out`) в ApplicationController вместо того чтобы просто писать весь функционал в SessionsController.
13. Создайте ссылку для выхода, которая будет вызывать метод `#delete` в контроллере сессии.  Понадобиться обманывать метод DELETE HTTP, но это легко делается путем передачи в `#link_to` опции `:method => :delete`.

#### Атентификация и посты

Давайте напишем эти секреты! Мы должны быть уверены, что видеть автора каждого поста могут только те пользователи, которые выполнили вход. Мы не собираемся волноваться о редактировании и удалении постов.

1. Создайте Post model и Posts controller и соответствующий ресурс в Routes файле, который позволяет использовать методы `[:new, :create, :index]`.
2. Поверх  Posts Controller, используй a `#before_filter` чтобы ограничить доступ к методам `#new` и`#create` только для участников, которые выполнили вход. Создайте обязательные вспомогательные методы в ApplicationController.
3. Для Posts Controller, подготовьте действие `#new`.
4. Напишите очень простую форму на странице `app/views/posts/new.html.erb`, которая будет создавать новый пост.
5. Сделайте так чтобы соответствующее действие `#create` создавало  пост, где внешний ключ автора ( например `user_id`) автоматически заполнялся основываясь на каком угодно вошедшем пользователе. Перенаправляйте на страницу Index, если все было удачно.
6. Заполните действие  `#index` в PostsController и создайте соответствующую страницу. Страница должна показывать список всех постов. 
7. Теперь добавьте логику в Index чтобы отобразить имя автора, но только если пользователь выполнил вход.
8. Выполните вход и создайте несколько секретных постов.
9. Протестируйте - выйдите и откройте страницу index. Вы должны видеть список постов, но не имена авторов. Войдите, и имена авторов должны появиться. Ваши секреты в безопасности!

Это, конечно, не полное решение... Нам необходимо создать новых пользователей с Rails консоли. Но это позволит Вам немного попрактиковаться и понять лучше аутентификацию. Попробуйте и возможно Вы будете следующим SnapChat.  


## Дополнительные материалы

*Этот раздел содержит полезные ссылки на дополнительные материалы. Они не обязательны, так что расценивайте их как нечто полезное, если вы хотите поглубже погрузиться в тему*


*
